# 💻 레디스를 캐시로
## 💡 레디스와 캐시
### ✅ 캐시란?
캐시란, 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소를 의미한다.  

<br>

캐시를 도입했을 때 성능을 효과적으로 개선할 수 있는 조건
- 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산을 통해 데이터를 가져와야 한다.
- 캐시에서 데이터를 가져온느 것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.
- 캐시에 저장된 데이터는 잘 변하지 않는 데이터다.
- 캐이세 저장된 데이터는 자주 검색되는 데이터다.

<br>

이상적인 캐시가 해결하는 문제점
- 원본 데이터 저장소 데이터를 가지고 오는 시간을 단축시킨다.
- 원본 데이터 저장소에서 데이터를 읽는 커넥션을 줄일 수 있다.
- 캐시를 적절하게 배치함으로써 애플리케이션의 확장 또한 가능하다.
- 원본 데이터 저장소에서 데이터를 가져올 때 CPU와 메모리 등의 리소스를 많이 사용했다면 캐시를 사용함으로써 애플리케이션 자체의 리소스를 줄일 수 있다.  
  ➡ 같은 값을 도출하기 위해 계속 같은 계산을 할 필요가 없으므로 리소스를 최적화싴리 수 있게 된다.
- 원본 데이터 저장소에 장애가 발생해 접근할 수 없는 상황이 발생하더라도 캐시에서 데이터를 가지고 올 수 있기 때문에 장애 시간을 줄일 수 있다는 장점이 있다.

<br>

### ✅ 캐시로서의 레디스
레디스의 장점
1. 단순하게 키-값 형태로 저장하므로 데이터를 저장하고 반환하는 것이 굉장히 간단하며, 자체적으로 다양한 자료 구조를 제공하기 때문에 애플리케이션에서 사용하던 list, hash 등의 자료 구조를 변환하는 과정 없이 레디스에 바로 저장할 수 있다.
2. 레디스는 모든 데이터를 메모리에 저장하는 인메모리 데이터 저장소이기 때문에 데이터를 검색하고 반환하는 것이 굉장히 빠르다.  
   ➡ 평균 읽기 및 쓰기 작업 속도가 1ms 미만이며, 초당 수백만 건의 작업이 가능하다.
3. 레디스는 자체적으로 고가용성 기능을 가지고 있는 솔루션이다.  
   ➡ 레디스의 센티널 또는 클러스터 기능을 사용하면 마스터 노드의 장애를 자동으로 감지해 페일오버를 발생시키기 때문에 운영자의 개입 없이 캐시는 정상적으로 유지될 수 있다.
4. 레디스의 클러스터를 사용하면 캐시의 스케일 아웃 또한 쉽게 처리할 수 있다.  
   ➡ 서비스의 규모에 따라 캐시 자체의 규모도 늘어나야 할 상황이 발생할 수 있는데, 자체 샤딩 솔루션인 클러스터를 사용하면 수평 확장이 굉장히 간단해진다는 장점이 존재한다.

<br>

### ✅ 캐싱 전략
**읽기 전략 - look aside**  
애플리케이션은 찾고자 하는 데이터가 먼저 캐시에 있는지를 확인한다.  
➡ 캐시에 데이터가 있으면 캐시에서 데이터를 읽어온다(캐시 히트).  
➡ 캐시에 데이터가 없으면 애플리케이션은 직접 데이터베이스에 접근해 찾고자 하는 데이터를 가져오고, 이를 다시 캐시에 저장한다(캐시 미스).

<br>

look aside 구조
- 장점: 레디스에 문제가 생겨 접근을 할 수 없는 상황이 발생하더라도 바로 서비스 장애로 이어지지 않고 데이터베이스에서 데이터를 가지고 올 수 있다.
- 단점: 기존에 애플리케이션에서 레디스를 통해 데이터를 가져오는 연결이 매우 많았다면 모든 커넥션이 한꺼번에 원본 데이터베이스로 몰려 많은 부하를 발생시키고, 이로 인해 원본 데이터베이스의 응답이 느려지거나, 리소스를 많이 차지하는 등의 이슈가 발생해 애플리케이션의 성능에 영향을 미칠 수 있다.  
  ➡ 캐시 스탬피드

<br>

`lazy loading`: 찾고자 하는 데이터가 레디스에 없을 때에만 레디스에 데이터를 저장하는 구조  
만약 기존에 사용 중인 서비스에 처음 레디스를 투입하거나 데이터베이스에만 새로운 데이터를 저장한다면?  
➡ 애플리케이션은 데이터를 찾기 위해 레디스에 매번 먼저 접근하고, 그때마다 캐시 미스가 일어나 데이터베이스와 레디스에 재접근하는 과정을 통해 지연이 초래돼 성능에 영향을 미칠 수 있다.  


<br>

캐시 워밍(cache warming): 이럴 때에는 미리 데이터베이스에서 캐시로 데이터를 밀어넣는 작업을 하기도 한다.  
➡ 공연 예매를 하는 애플리케이션에서 새로운 공연 정보 상품이 오픈하기 전에 데이터베이스에 저장된 데이터를 레디스로 밀어넣는 캐시 워밍 작업을 거치는 것이 효율적일 수 있다.

<br>

**쓰기 전략과 캐시의 일관성**  
**1. write through**  
![write_through.jpeg](../../res/write_through.jpeg)  
`write through` 방식은 데이터베이스에 업데이트할 때마다 매번 캐시에도 데이터를 함께 업데이트시키는 방식이다.  
캐시는 항상 최신 데이터를 가지고 있을 수 있다는 장점이 있지만, 데이터는 매번 2개의 저장소에 저장돼야하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다는 단점이 있다.  
이 방식의 경우 다시 사용되지 않을 데이터가 저장될 수 있기 때문에, 일종의 리소스 낭비가 발생할 수 있다.  
➡ 이 방식을 사용할 경우 데이터를 저장할 때 만료 시간을 사용할 것을 권장한다.

<br>

**2. cache invalidation**  
![cache_invalidation.jpeg](../../res/cache_invalidation.jpeg)  
데이터베이스게 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략이다.  
저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 훨씬 리소스를 적게 사용하기 때문에 앞선 `write through`의 단점을 보완한 방법이다.

<br>

**3. write behind(write back)**  
![write_behind.jpeg](../../res/write_behind.jpeg)  
만약 쓰기가 빈번하게 발생하는 서비스라면 `write behind` 방식을 고려해볼 수 있다.  
데이터베이스에 대량의 쓰기 작업이 발생하면 이는 많은 디스크 I/O를 유발해, 성능 저하가 발생할 수 있다.  
➡ 따라서 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트한 뒤, 이후에는 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트하는 것이다.

<br>

예를 들어 유튜브와 같은 스트리밍 사이트의 좋아요 수는 매번 실시간 집계가 필요하진 않다.  
좋아요를 누른 데이터를 우선 레디스에 저장해둔 다음 5분 간격으로 이를 집계해 데이터베이스에 저장하는 과정을 거친다면 데이터베이스의 성능을 향상시켜 애플리케이션의 성능도 향상시킬 수 있다.  
물론 이 방법에서는 캐시에 문제가 생겨 데이터가 날아갈 경우 최대 5분 동안의 데이터가 날아갈 수 있다는 위험성이 있음을 감수해야 한다.

