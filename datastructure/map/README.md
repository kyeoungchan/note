# ğŸ’» HashMap vs HashTable vs ConcurrentHashMap vs LinkedHashMap

## âœ… HashMap
- ë°ì´í„°ë¥¼ ì €ì¥í•  ë•Œ í‚¤-ê°’ ìŒìœ¼ë¡œ ì €ì¥í•œë‹¤.
- í‚¤ëŠ” ì¤‘ë³µë˜ì§€ ì•Šìœ¼ë©°, `null`ì„ í—ˆìš©í•œë‹¤.(ì¦‰, `null` í‚¤ë„ í•˜ë‚˜ë§Œ ì €ì¥ë  ìˆ˜ ìˆë‹¤.)
- ê°’ì€ ì¤‘ë³µë˜ì–´ë„ ìƒê´€ì—†ìœ¼ë©°, `null`ë„ í—ˆìš©í•œë‹¤.
- `HashMap`ì€ ë™ê¸°í™”ê°€ ë˜ì–´ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ë•ŒëŠ” ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤.

### ğŸ’¡ HashMapì—ì„œ ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ë™ì‹œì ‘ê·¼í•  ë•Œ ìƒê¸°ëŠ” ë¬¸ì œì 
1. í•´ì‹œ ì¶©ëŒì´ ë°œìƒí•˜ëŠ” ê²½ìš°, ê°™ì€ ì¸ë±ìŠ¤ì— ì—¬ëŸ¬ ë°ì´í„°ê°€ ì¤‘ë³µë˜ì–´ ì €ì¥ë  ìˆ˜ ìˆë‹¤.
   - ì´ë•ŒëŠ” `LinkedList`ë¥¼ ì´ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ì¶”ê°€ë¡œ ì—°ê²°í•˜ëŠ”ë°, ë°ì´í„°ê°€ ë§ì´ ìŒ“ì´ë©´ ê²€ìƒ‰ ì†ë„ê°€ ëŠë ¤ì§€ê²Œ ëœë‹¤.
   - ì´ëŸ° ìƒí™©ì—ì„œ `HashMap`ì€ ì¼ì • ê¸¸ì´ ì´ìƒì˜ `LinkedList`ë¥¼ ê°€ì§€ê²Œ ë˜ë©´, í•´ë‹¹ ì¸ë±ìŠ¤ì— ëŒ€í•œ ëª¨ë“  ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ ìœ„ì¹˜ë¡œ ì´ë™ì‹œì¼œì•¼í•˜ëŠ” ë°ì´í„°ì˜ ì¬ë¹„ì¹˜(rehashing)ê°€ ë°œìƒí•˜ê²Œ ëœë‹¤. 
2. í•œ ì“°ë ˆë“œê°€ HashMapì˜ ê°’ì„ ìˆ˜ì •í•˜ëŠ” ë„ì¤‘ ë‹¤ë¥¸ ì“°ë ˆë“œê°€ ê°™ì€ ìœ„ì¹˜ì— ìˆëŠ” ê°’ì„ ìˆ˜ì •í•œë‹¤ë©´, ê°’ì´ ë®ì–´ì¨ì§€ëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
3. ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ ë™ì‹œì— `HashMap`ì— ë°ì´í„°ë¥¼ ì¶”ê°€í•˜ë©´, ë°°ì—´ì˜ í¬ê¸°ê°€ ëŠ˜ì–´ë‚˜ì•¼í•˜ëŠ” ìƒí™©ì—ì„œë„ ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ë™ì‹œì— ë°°ì—´ì˜ í¬ê¸°ë¥¼ ì¡°ì •í•˜ë ¤ê³  í•  ìˆ˜ ìˆë‹¤.
   - ì´ëŸ° ê²½ìš° ì„œë¡œ ë‹¤ë¥¸ ì“°ë ˆë“œê°€ ë™ì‹œì— ë°°ì—´ì˜ í¬ê¸°ë¥¼ ì¦ê°€ì‹œí‚¤ë ¤ê³  í•  ìˆ˜ ìˆìœ¼ë©°, ì´ë¡œ ì¸í•´ ë°°ì—´ì˜ í¬ê¸°ê°€ ë„ˆë¬´ ì»¤ì ¸ì„œ ë°ì´í„°ì˜ ì¬ë°°ì¹˜(rehashing)ê°€ ìì£¼ ë°œìƒí•˜ê²Œ ëœë‹¤.

> ì¬ë°°ì¹˜(rehashing)ì´ë€?  
> HashMapì€ ë‚´ë¶€ì ìœ¼ë¡œ ë°°ì—´ê³¼ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ì €ì¥í•œë‹¤.  
> ì´ë•Œ ë°°ì—´ì˜ í¬ê¸°ëŠ” HashMapì˜ ì´ˆê¸° í¬ê¸°ì™€ ë¡œë“œ íŒ©í„°(Load Factor)ì— ë”°ë¼ ê²°ì •ëœë‹¤.
> ë§Œì•½ ë°°ì—´ì˜ í¬ê¸°ê°€ ì´ˆê¸°ì— ì„¤ì •ëœ ê°’ë³´ë‹¤ ì‘ì•„ì§€ë©´, ë°°ì—´ì˜ í¬ê¸°ë¥¼ ëŠ˜ë¦¬ê³  ëª¨ë“  ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ ë°°ì—´ì— ë‹¤ì‹œ í•´ì‹±í•´ì•¼ í•œë‹¤.  
> ì´ ì‘ì—…ì´ ë°”ë¡œ ë°ì´í„°ì˜ ì¬ë°°ì¹˜(rehashing)ì´ë‹¤.

ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ì„œëŠ” `ConcurrentHashMap`ì„ ì‚¬ìš©í•˜ê±°ë‚˜, `HashMap`ì„ ë™ê¸°í™”í•˜ëŠ” ë°©ë²•ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.  
`ConcurrentHashMap`ì€ ë™ì‹œì— ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ì ‘ê·¼í•´ë„ ì•ˆì „í•˜ê²Œ ë°ì´í„°ë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆë„ë¡ ë™ê¸°í™”ë¥¼ ì œê³µí•œë‹¤.  
ë˜í•œ, `HashMap`ì„ ë™ê¸°í™”í•  ê²½ìš°ì—ëŠ” ë™ê¸°í™”ëœ ë¸”ë¡ìœ¼ë¡œ `HashMap`ì˜ ì ‘ê·¼ì„ ì œì–´í•˜ì—¬ ë°ì´í„°ì˜ ì¼ê´€ì„±ì„ ë³´ì¥í•  ìˆ˜ ìˆë‹¤.

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {

    public V get(Object key) {}
    public V put(K key, V value) {}
}
```

<br>

## âœ… HashTable
- `HashMap`ê³¼ ìœ ì‚¬í•œ í•´ì‹œ í…Œì´ë¸” êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ì§€ë§Œ, `HashMap`ê³¼ ë‹¬ë¦¬ ë™ê¸°í™”(Synchronization)ì„ ì œê³µí•œë‹¤.
- ì¦‰, ë©€í‹°ì“°ë ˆë“œ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- í•˜ì§€ë§Œ ë™ê¸°í™”ë¥¼ ì œê³µí•˜ë¯€ë¡œ ì„±ëŠ¥ë©´ì—ì„œëŠ” `HashMap`ë³´ë‹¤ ë–¨ì–´ì§€ëŠ” ê²½ìš°ê°€ ìˆë‹¤.
- ë˜í•œ, `null` ê°’ì„ í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.

### ğŸ’¡ HashTableì´ ì–´ë–¤ì‹ìœ¼ë¡œ ë™ê¸°í™”ë¥¼ ì œê³µí•˜ëŠ”ê°€?
- `HashTable`ì€ ëª¨ë“  ë©”ì„œë“œì— `synchronized` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬, ì“°ë ˆë“œ ê°„ì— ë™ê¸°í™”ë¥¼ ì œê³µí•œë‹¤.
  - `synchronized` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´, í•œ ë²ˆì— í•˜ë‚˜ì˜ ì“°ë ˆë“œë§Œ í•´ë‹¹ ë©”ì„œë“œì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ ì œí•œí•œë‹¤.
  - ë”°ë¼ì„œ, ë™ê¸°í™”ë¥¼ ì œê³µí•¨ìœ¼ë¡œì¨ ë©€í‹°ì“°ë ˆë“œ í™˜ê²½ì—ì„œ ë°ì´í„° ì¼ê´€ì„± ë¬¸ì œë¥¼ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.
- í•˜ì§€ë§Œ, `synchronized` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì„±ëŠ¥ì´ ì €í•˜ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, Java 1.5ë¶€í„°ëŠ” `ConcurrentHashMap`ì´ë‚˜ `Collections.synchronizedMap` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë™ì‹œì„±ì„ ë³´ì¥í•˜ëŠ” Map ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê¶Œì¥ëœë‹¤.
  - ì´ëŸ¬í•œ ìë£Œêµ¬ì¡°ë“¤ì€ `HashTable`ê³¼ ë‹¬ë¦¬, ë½(lock)ì„ ë”ìš± ì„¸ë¶„í™”í•˜ì—¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¨ë‹¤.

```java
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {

    public synchronized int size() { }

    @SuppressWarnings("unchecked")
    public synchronized V get(Object key) { }

    public synchronized V put(K key, V value) { }
}
```

<br>

## âœ… ConcurrentHashMap
- `ConcurrentHashMap`ì€ ë©€í‹°ì“°ë ˆë“œ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í•´ì‹œ í…Œì´ë¸” êµ¬ì¡°ë‹¤.
- `HashMap`ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ë™ê¸°í™”ë¥¼ ì ìš©í•˜ëŠ” ëŒ€ì‹  ì„¸ë¶„í™”ëœ ë½(lock)ì„ ì‚¬ìš©í•˜ì—¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œì¼°ë‹¤.

### ğŸ’¡ ConcurrentHashMapì€ ì–´ë–¤ì‹ìœ¼ë¡œ Lockì„ ì‚¬ìš©í•˜ëŠ”ê°€?
1. ì„¸ê·¸ë¨¼íŠ¸ ë½(Segment Lock)
   - `ConcurrentHashMap`ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì—¬ëŸ¬ ê°œì˜ ì„¸ê·¸ë¨¼íŠ¸(Segment)ë¡œ ë‚˜ë‰˜ì–´ì ¸ ìˆë‹¤.
   - ê° ì„¸ê·¸ë¨¼íŠ¸ëŠ” ìì²´ì ìœ¼ë¡œ ë½ì„ ê°€ì§€ê³  ìˆìœ¼ë©°, ì„œë¡œ ë…ë¦½ì ìœ¼ë¡œ ì‘ë™í•œë‹¤.
   - ì´ë¥¼ í†µí•´ ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•´ë„ ì„œë¡œ ë‹¤ë¥¸ ì„¸ê·¸ë¨¼íŠ¸ì—ì„œ ì‘ì—…í•˜ë¯€ë¡œ, ë½ ì¶©ëŒì´ ë°œìƒí•  í™•ë¥ ì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
2. ì—”íŠ¸ë¦¬ ë½(Entry Lock)
   - `ConcurrentHashMap`ì€ ê° ì—”ë“œë¦¬(Entry)ì— ëŒ€í•´ ë½ì„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
   - ê° ì„¸ê·¸ë¨¼íŠ¸ëŠ” ì—”íŠ¸ë¦¬ ë½ì„ ì‚¬ìš©í•˜ì—¬, í•´ë‹¹ ì„¸ê·¸ë¨¼íŠ¸ ë‚´ì—ì„œ ë™ì‹œì— ì ‘ê·¼í•˜ë ¤ëŠ” ì—¬ëŸ¬ ì“°ë ˆë“œ ê°„ì˜ ê²½ìŸì„ ì œì–´í•œë‹¤.
   - ì—”íŠ¸ë¦¬ ë½ì€ ì„¸ê·¸ë¨¼íŠ¸ ë½ë³´ë‹¤ ì‘ì€ ë²”ìœ„ì—ì„œ ë½ ì¶©ëŒì´ ë°œìƒí•  í™•ë¥ ì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.

### ğŸ’¡ í•´ì‹œë²„ì¼“ê³¼ ì„¸ê·¸ë¨¼íŠ¸
`ConcurrentHashMap`ê°€ ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜ëŠ”, ë‚´ë¶€ì ìœ¼ë¡œ ì—¬ëŸ¬ ê°œì˜ í•´ì‹œ ë²„í‚·ì„ ì—¬ëŸ¬ ê°œì˜ ì„¸ê·¸ë¨¼íŠ¸(Segment)ë¡œ ë¶„í• í•˜ì—¬ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ë‹¤.  
ê° ì„¸ê·¸ë¨¼íŠ¸ëŠ” ìì²´ì ìœ¼ë¡œ ë™ê¸°í™” ë˜ì–´ìˆìœ¼ë¯€ë¡œ, ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ ë™ì‹œì— ì ‘ê·¼í•´ë„ ì•ˆì „í•˜ê²Œ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

![hash_bucket_and_segment.png](../res/hash_bucket_and_segment.png)

**í•´ì‹œë²„í‚·**  
í•´ì‹œ í…Œì´ë¸”ì—ì„œ ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ê³µê°„ì´ë‹¤.  
í•´ì‹œë²„í‚·ì€ ì¼ë°˜ì ìœ¼ë¡œ `LinkedList` í˜¹ì€ `Tree` êµ¬ì¡°ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤.  
ê°ê°ì˜ í•´ì‹œë²„í‚·ì€ ë°°ì—´ì˜ í•œ ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ë©°, ë²„í‚· ë‚´ë¶€ì—ëŠ” í‚¤(Key)ì™€ ê°’(Value) ìŒì„ ì €ì¥í•˜ëŠ” ì—”íŠ¸ë¦¬(Entry) ê°ì²´ê°€ ì €ì¥ëœë‹¤.  
í•´ì‹œ í•¨ìˆ˜ì— ì˜í•´ ê³„ì‚°ëœ í•´ì‹œ ê°’ì´ ë²„í‚·ì˜ ì¸ë±ìŠ¤ë¡œ ì‚¬ìš©ëœë‹¤.

<br>

**ì—¬ëŸ¬ ê°œì˜ ì„¸ê·¸ë¨¼íŠ¸(segment)ë¡œ ë¶„í• **  
`ConcurrentHashMap`ì€ ë‚´ë¶€ì ìœ¼ë¡œ ì„¸ê·¸ë¨¼íŠ¸ë¼ëŠ” ì‘ì€ í•´ì‹œ í…Œì´ë¸”ì„ ì—¬ëŸ¬ ê°œ ë§Œë“¤ì–´ì„œ ê´€ë¦¬í•œë‹¤.  
ì „ì²´ í•´ì‹œ í…Œì´ë¸”ì„ í•˜ë‚˜ì˜ í° í•´ì‹œ ë²„í‚·ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì‘ì€ ì„¸ê·¸ë¨¼íŠ¸ ë‹¨ìœ„ë¡œ ë¶„í• í•˜ì—¬ ë³‘ë ¬ì„±ì„ ë†’ì´ëŠ” ê²ƒì´ë‹¤.  

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>(16, 0.75f, 4);
// ì´ˆê¸° í¬ê¸°: 16, ë¡œë“œ íŒ©í„°(load factor): 0.75, ì„¸ê·¸ë¨¼íŠ¸ ê°œìˆ˜: 4

map.put("apple", 1);
map.put("banana", 2);
map.put("cherry", 3);
map.put("date", 4);
map.put("eggplant", 5);
map.put("fig", 6);
map.put("grape", 7);
map.put("honeydew", 8);
```
> ì˜ˆë¥¼ ë“¤ì–´, "apple"ì˜ í•´ì‹œ ê°’ì´ 0ì´ë©´, 0ë²ˆ ì„¸ê·¸ë¨¼íŠ¸ì— ì €ì¥ë˜ê³ , "banana"ì˜ í•´ì‹œ ê°’ì´ 1ì´ë©´, 1ë²ˆ ì„¸ê·¸ë¨¼íŠ¸ì— ì €ì¥ëœë‹¤.  
> ê°ê°ì˜ ì„¸ê·¸ë¨¼íŠ¸ëŠ” ë…ë¦½ì ìœ¼ë¡œ ì ê¸ˆì„ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ, ì—¬ëŸ¬ ì“°ë ˆë“œì—ì„œ ë™ì‹œì— ì ‘ê·¼í•˜ë”ë¼ë„ ì„¸ê·¸ë¨¼íŠ¸ ê°„ì˜ ì¶©ëŒì´ë‚˜ ê²½í•© ì—†ì´ ì•ˆì „í•˜ê²Œ ì‘ì—…ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤.

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {

    private static final int DEFAULT_CAPACITY = 16;

    // ë™ì‹œì— ì—…ë°ì´íŠ¸ë¥¼ ìˆ˜í–‰í•˜ëŠ” ì“°ë ˆë“œ ìˆ˜
    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
    
    public V get(Object key) {}

    public boolean containsKey(Object key) { }

    public V put(K key, V value) {
        return putVal(key, value, false);
    }

    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
}
```
<br>

## âœ… LinkedHashMap
`LinkedHashMap`ì€ ë°ì´í„°ì˜ ì‚½ì… ìˆœì„œë¥¼ ìœ ì§€í•˜ëŠ” í•´ì‹œ í…Œì´ë¸”ê³¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ê²°í•©í•œ ìë£Œêµ¬ì¡°ë‹¤.  
ë°ì´í„°ë¥¼ ì €ì¥í•  ë•Œ ìˆœì„œëŒ€ë¡œ ì €ì¥í•˜ê¸° ë•Œë¬¸ì—, ë°ì´í„°ì˜ ìˆœì„œê°€ ì¤‘ìš”í•œ ìƒí™©ì—ì„œ ì‚¬ìš©í•˜ê¸° ì í•©í•˜ë‹¤.  
`LinkedHashMap`ì€ ë™ê¸°í™” ë˜ì–´ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— ë©€í‹° ì“°ë ˆë“œ í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ë•ŒëŠ” ì£¼ì˜ê°€ í•„ìš”í•˜ë‹¤.

<br>


**ì¶œì²˜**  
[[JAVA] HashMap, HashTable, ConcurrentHashMap,LinkedHashMap ì°¨ì´](https://peonyf.tistory.com/entry/JAVA-HashMap%EC%99%80-Enum)  
[[Java] ConcurrentHashMap ì´ë€ ë¬´ì—‡ì¼ê¹Œ?](https://devlog-wjdrbs96.tistory.com/269)  
[ConcurrentHashMapì— ëŒ€í•´ ì•Œì•„ë³´ì](https://parkmuhyeun.github.io/woowacourse/2023-09-09-Concurrent-Hashmap/)