# 💻 노드

## ✅ 노드란
- 엘라스틱서치에서 클러스터를 구성하는 요소를 노드(node)라고 한다(하나의 인스턴스다).  
- 클러스터는 여러 노드의 집합인데, 노드는 엘라스틱서치가 설치되는 물리적 혹은 논리적 단위다.
  - 일반적으로 하나의 컴퓨터(혹은 서버)에 하나의 노드를 구성하는데, 물리적인 서버뿐만 아니라 논리 혹은 가상 서버로도 노드를 구분한다.
- 물리적인 서버 하나에 노드 하나를 구성하는 방식을 권장하지만, 단일 서버에 복수의 노드를 설치할 수도 있다.
- 클러스터에 참여하는 노드 이름은 중복돼서는 안 된다.
- 하나의 노드가 여러 역할을 할 수 있다.

<br>

### 💡 마스터 노드
클러스터는 반드시 하나의 마스터 노드(master node)를 가져야 한다.

<br>

아래를 포함하여 클러스터의 모든 상태 정보를 관리한다.
1. 인덱스의 설정
2. 매핑 정보
3. 물리적 위치
4. 클러스터 설정 정보
5. 인덱스 템플릿 정보

<br>

각 노드들과 통신하면서 클러스터의 변화를 모니터링한다.

마스터 노드가 없으면 클러스터가 멈춘다.  
→ 다수의 마스터 후보 노드가 투표를 통해 결정한다.  
→ 사용자는 마스터 후보 노드(master-eligible node)만 지정할 수 있다.
→ 클러스터 내부에서 N/2 + 1(N은 마스터 후보 노드 수) 표를 얻은 마스터 후보 노드가 과반수에 의해 마스터 노드가 된다.


<br>

### 💡 투표 전용 노드
7.3 버전부터 마스터 후보 노드 중에서 마스터 노드를 선정하는 투표에는 참여하지만 실제 마스터 노드가 되지 않는 노드들이 추가되었다.  
투표에만 참여하는 노드라는 것이 무슨 의미가 있을까? 🤔

<br>

**❗️ 마스터 후보 노드 부족으로 마스터 노드를 선출하지 못하는 경우**  

퍼블릭 클라우드 환경에서는 물리적인 거리 제한 없이 아시아, 유럽, 북미에 노드를 구성해 클러스터를 만들 수 있다.  
이때 지진으로 서버 오류가 발생해 아시아존에 있던 모든 노드가 동작하지 않는 상황에서 투표 전용 노드(voting only node)를 이용해 시스템을 정상으로 유지하는 방법을 알아보자.  

![elastic_stack_cannot_vote.jpeg](../res/elastic_stack_cannot_vote.jpeg)

위의 상황에서는 최소 마스터 후보 노드 수가 부족해서 클러스터는 마스터 노드를 선출할 수 없고 시스템은 중단된다.

<br>

![elastic_stack_voting_only_node.jpeg](../res/elastic_stack_voting_only_node.jpeg)

노드1이 마스터 노드가 되었고 아시아존에 문제가 발생했지만 클러스터는 동작한다.

<br>

### 💡 데이터 노드
데이터 노드(data node)는 인덱싱한 도큐먼트를 샤드 형태로 저장하여 데이터의 CRUD 작업과 검색, 집계 작업을 한다.  
실질적인 데이터 프로세싱 작업이 일어나기 때문에 일반적으로 노드 중 가장 많은 부하를 받는다.  
→ 여유가 된다면 클러스터를 구성할 때 마스터 노드와 데이터 노드 역할을 구분하는 방식도 좋다.  
→ 데이터 노드의 부하로 인해 마스터 노드의 성능이 떨어질 경우 클러스터 전체의 안정성에 영향을 미치기 때문이다.

데이터 노드는 컴퓨터 리소스(I/O, CPU, 메모리 등) 사용량에 민감하기 때문에 모니터링하면서 부하 상태를 체크하고 상황에 맞춰 명시적으로 샤드를 재분배하거나 데이터 노드를 추가/변경하는 작업을 해야 한다.  

![data_node.jpeg](../res/data_node.jpeg)  
클러스터 내의 4개 데이터 노드를 모니터링해야 하는 이유는 다음과 같다.  
- 노드 1: 이미 리소스 한계에 왔다.
- 노드 2: 한계에 도달하려고 한다.
- 노드 3: 여유가 있다.
- 노드 4: 이제 막 클러스터에 합류했다.

➡ 적당한 리소스 배치를 통해 특정 노드에 부하가 몰리는 것을 막아햐 하는데, 위의 경우 데이터 노드1의 샤드를 데이터 노드4에 재분배하면 된다.

<br>


### 💡 인제스트 노드
인제스트 노드(ingest node)는 도큐먼트의 가공과 정제를 위한 인제스트 파이프라인이 실행되는 노드다.  
인제스트 노드는 파이프라인을 통해 도큐먼트를 엘라스틱서치에 인덱싱하기 전에 원하는 형태로 변형할 수 있다.  
> 로그스태시의 필터와 기능적으로 유사하지만 몇 가지 차이점이 있다.
> - 인제스트 노드는 실행 주체가 엘라스틱서치라는 점과 지원되는 기능에 일부 차이가 있다.
> - 로그스태시 설치 없이 비츠만 설치해 데이터를 수집하고, 인제스트 파이프라인을 이용해 이를 가공할 수 있다.
> - 가볍고 간단한 수집 프로세스라면 비츠와 인제스트 노드의 조합만으로 충분하고,
> - 좀 더 무겁고 복합한 가공이 필요하다면 로그스태시까지 함께 사용하자.


<br>

인제스트 노드는 프로세서와 파이프라인이라는 구성요소를 갖고 있다.  
- 프로세서: 도큐먼트를 변형할 수 있는 기능적으로 구분되는 모듈  
- 파이프라인: 프로세서의 집합  

<br>

```
# 인제스트 노드의 파이프라인 생성 요청
PUT _ingest/pipeline/mypipe
{
    "description": "my description",
    "processors": [
        {
            "set": {
                "field": "status",
                "value": "low",

                "on_failure": [
                    {
                        "set": {
                            "field": "error",
                            "value": "set processor error"
                        }
                    }
                ]
            }
        }
    ],
    "on_failure": [
        {
            "set": {
                "field": "error",
                "value": "pipeline1"
            }
        }
    ]
}
```

- `mypipe`: 파이프라인 이름
- `set`: 프로세서 이름
- `status`라는 필드가 없다면 새로 만들고 값을 `low`로 할당, 이미 있다면 값을 `low`로 수정한다.
- `on_failure`는 2개가 있는데, 프로세서 동작 중에 발생하는 예외를 처리하는 것과 파이프라인에서 발생하는 오류에 대한 예외를 처리하는 것으로 나뉜다.

<br>

```json
# 파이프라인을 적용하여 도큐먼트 저장 요청
PUT my_index/_doc/1?pipeline=mypipe
{
    "name": "id1",
    "status": "high"
}
# status: low
GET my_index/_search
```

```json
# my_index2 인덱스 생성과 도큐먼트 인덱싱 요청
PUT my_index2/_doc/1
{
    "name": "id1",
    "status": "high"
}
PUT my_index2/_doc/2
{
    "name": "id2"
}

# update_by_query API를 사용해 기존 인덱스에 파이프라인 적용 요청
POST my_index2/_update_by_query?pipeline=mypipe
```

```json
# reindex API를 사용해 새로운 인덱스에 파이프라인 적용 요청
POST _reindex
{
    "source": {
        "index": "my_index2"
    },
    "dest": {
        "index": "my_index3",
        "pipeline": "mypipe"
    }
}
```
> 수정해야하는 도큐먼트가 많다면 update API를 사용해 도큐먼트를 일일이 수정하는 방식(my_index2) 대신 리인덱싱과 파이프라인을 조합해 새로운 인덱스를 생성하는 방식(my_index3)이 성능상 유리할 수 있다.  
> 업데이트는 내부적으로 검색, 해당 도큐먼트 삭제, 수정된 도큐먼트 리인덱싱의 순서로 작업이 일어나는데, 삭제된 도큐먼트는 세그먼트 머지가 발생하기 전까지 ID만 내부적으로 기록해뒀다가 검색 시 필터링 하는 방식이어서 ➡ 성능에 나쁜 영향을 미치기 때문에 도큐먼트 업데이트는 가급적 피한느 것이 좋다.

```json
# 인덱스 설정에서 파이프라인 적용 요청
PUT my_index4
{
    "settings": {
        "default_pipeline": "mypipe"
    }
}
```

<br>

**출처**  
[엘라스틱 스택 개발부터 운영까지](https://product.kyobobook.co.kr/detail/S000001932755)