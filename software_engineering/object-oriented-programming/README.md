# 🔥 객체지향 설계
## 객체지향 설계 원칙(SOLID)
객체지향 프로그래밍에서 유지보수 가능하고 확장 가능한 소프트웨어를 설계하기 위한 다섯 가지 원칙의 앞글자를 딴 약어이다.
1. 단일 책임의 원칙(Single Responsibility Principle)
   - 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙
     - 이를 통해 클래스는 한 가지 책임에 집중하며, 변경이 발생할 경우 클래스만 수정하면 된다.
   - 객체지향 프로그래밍의 5원칙 중 나머지 4원칙의 기초 원칙
   - ex) 주문 관리 시스템에서 주문 정보를 처리하는 클래스 - 주문 생성, 수정, 삭제 관련 책임만 지닌다.
2. 개방 폐쇄 원칙(Open Closed Principle)
   - 소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙
     - 즉, 기존 코드를 수정하지 않고도 기능을 확장할 수 있어야 한다.
   - ex) 도형 그리는 프로그램 - 도형 종류가 늘어날 때마다 기존 로직은 변경하지 않고 새로운 도형을 추가하게끔 설계
3. 리스코프 치환의 원칙(Liskov Substitution Principle)
   - 서브 타입(상속받은 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙
     - 즉, 어떤 클래스가 상위 클래스를 상속받을 때, 이 클래스를 사용하는 코드는 상위 클래스의 인스턴스를 언제나 대체 가능한 하위 클래스의 인스턴스로 취급할 수 있어야 한다.
   - ex) Car 인터페이스의 엑셀 메서드: 무조건 앞으로 가는 기능 제공!
4. 인터페이스 분리의 원칙(Interface Segregation Principle)
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
      - 즉, 인터페이스는 작고 응집력 있는 단위로 분리되어야 한다.
    - 인터페이스는 클라이언트가 필요로 하는 기능에만 집중되어야 하며, 불필요한 메서드를 포함하지 않아야 한다.
    - ex) `createOrder()`, `updateOrder()`, `deleteOrder()` 메서드를 포함하는 주문처리 인터페이스 / 주문 조회와 같은 필요없을 수 있는 기능을 분리한다.
5. 의존성 역전의 원칙(Dependency Inversion Principle)
   - 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙
     - 즉, 추상화에 의존해야하며, 구체화에는 의존하면 안 된다.
   - 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 양쪽 모두 추상화에 의존해야한다.
   - 추상화된 인터페이스나 추상 클래스를 통해 의존성을 주입받아야 한다.
   - ex) 인터페이스 `MemberRepository`를 의존하고 있는 `MemberService`와 `MemberRepository`를 구현하는 `MemberJPARepository`와 `MemberMyBatisRepository`

> SOLID 원칙을 통해 코드의 유지보수성, 확장성, 재사용성, 테스트 용이성 등이 향상되며, 더 풍부하고 유연한 객체지향 소프트웨어 개발이 가능하다.

출처  
[spring_@Autowired](https://github.com/devSquad-study/2023-CS-Study/blob/main/Spring/spring_%40Autowired.md)